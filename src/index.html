<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="resume, research, projects" />
    <meta name="description"
        content="The personal website for Steven Hicks, a developer and research based in Oslo, Norway.">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="stylesheet" type="text/css" href="./style.css" />
    <title>Steven Hicks</title>
    <script>
        (function () {
            const now = new Date();
            const month = now.getMonth();
            const day = now.getDate();

            const isAutumn = month === 8 || month === 10;
            const isHalloween = month === 9;
            const isDecember = month === 11;
            // const isNewYear = (month === 11 && day === 31) || (month === 0 && day === 1);
            const isNewYear = true;

            if (!isDecember && !isNewYear && !isAutumn && !isHalloween) return;

            if (isDecember || isNewYear) {
                document.documentElement.classList.add('december');
            }

            if (isHalloween) {
                document.documentElement.classList.add('halloween');
            }

            document.addEventListener('DOMContentLoaded', function () {
                const canvas = document.createElement('canvas');
                canvas.id = 'effect-canvas';
                canvas.style.position = 'fixed';
                canvas.style.top = '0';
                canvas.style.left = '0';
                canvas.style.pointerEvents = 'auto';
                canvas.style.zIndex = '-1';
                document.body.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                const DPR = window.devicePixelRatio || 1;

                let width, height;

                function resizeCanvas() {
                    width = window.innerWidth;
                    height = window.innerHeight;
                    canvas.width = width * DPR;
                    canvas.height = height * DPR;
                    canvas.style.width = width + 'px';
                    canvas.style.height = height + 'px';
                    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
                }

                window.addEventListener('resize', resizeCanvas);
                resizeCanvas();

                if (isNewYear) {
                    // Fireworks for New Year's Eve and Day
                    const CONFIG = {
                        // Physics
                        gravity: 0.12,
                        airResistance: 0.995,

                        // Launch timing
                        launchInterval: 300,      // ms between launches
                        maxFireworks: 10,          // max simultaneous rockets

                        // Launch distribution (must sum to 1.0)
                        leftLaunchChance: 0.20,   // 35% from left
                        rightLaunchChance: 0.20,  // 35% from right (remainder from bottom)

                        // Side launches (left/right)
                        sideStartY: [0.7, 0.95],      // start height range (% of screen)
                        sideTargetY: [0.05, 0.25],    // explosion height range
                        sideTargetX: [0.2, 0.8],      // horizontal target range
                        sideSpeed: [10, 14],          // speed range

                        // Bottom launches
                        bottomStartX: [0.1, 0.9],     // horizontal start range
                        bottomTargetY: [0.05, 0.30],  // explosion height range
                        bottomSpeed: [12, 17],        // speed range

                        // Explosions
                        particleCount: [80, 130],     // particles per explosion
                        particleSpeed: [4, 7],        // base explosion speed
                        particleDecay: [0.008, 0.020],
                        particleRadius: [1.5, 4],
                        twinkleChance: 0.3,

                        // Trail fade (lower = longer persistence)
                        trailFade: 0.18
                    };

                    const fireworks = [];
                    const particles = [];
                    const sparks = [];
                    const colors = [
                        ['#ff0000', '#ff6666', '#ffaaaa'],
                        ['#ff6600', '#ff9944', '#ffcc88'],
                        ['#ffff00', '#ffff66', '#ffffaa'],
                        ['#00ff00', '#66ff66', '#aaffaa'],
                        ['#00ffff', '#66ffff', '#aaffff'],
                        ['#0066ff', '#4488ff', '#88aaff'],
                        ['#ff00ff', '#ff66ff', '#ffaaff'],
                        ['#ffd700', '#ffe44d', '#ffee99']
                    ];

                    // Generate city skyline
                    let cityPath = null;
                    let buildings = [];
                    function generateCity() {
                        cityPath = new Path2D();
                        buildings = [];
                        const baseY = height * 0.75;
                        let x = 0;

                        cityPath.moveTo(0, height);
                        cityPath.lineTo(0, baseY);

                        while (x < width + 100) {
                            const buildingWidth = 30 + Math.random() * 60;
                            const buildingHeight = 50 + Math.random() * 200;
                            const buildingTop = baseY - buildingHeight;

                            // Store building data for windows
                            buildings.push({
                                x: x,
                                y: buildingTop,
                                width: buildingWidth,
                                height: buildingHeight
                            });

                            // Building left side
                            cityPath.lineTo(x, baseY);
                            cityPath.lineTo(x, buildingTop);

                            // Roof variations
                            const roofType = Math.random();
                            if (roofType < 0.3) {
                                // Flat roof with antenna
                                cityPath.lineTo(x + buildingWidth * 0.4, buildingTop);
                                cityPath.lineTo(x + buildingWidth * 0.4, buildingTop - 15);
                                cityPath.lineTo(x + buildingWidth * 0.45, buildingTop - 15);
                                cityPath.lineTo(x + buildingWidth * 0.45, buildingTop - 30);
                                cityPath.lineTo(x + buildingWidth * 0.5, buildingTop - 30);
                                cityPath.lineTo(x + buildingWidth * 0.5, buildingTop - 15);
                                cityPath.lineTo(x + buildingWidth * 0.55, buildingTop - 15);
                                cityPath.lineTo(x + buildingWidth * 0.55, buildingTop);
                                cityPath.lineTo(x + buildingWidth, buildingTop);
                            } else if (roofType < 0.5) {
                                // Pointed roof
                                cityPath.lineTo(x + buildingWidth * 0.5, buildingTop - 25);
                                cityPath.lineTo(x + buildingWidth, buildingTop);
                            } else if (roofType < 0.7) {
                                // Stepped roof
                                cityPath.lineTo(x + buildingWidth * 0.3, buildingTop);
                                cityPath.lineTo(x + buildingWidth * 0.3, buildingTop - 20);
                                cityPath.lineTo(x + buildingWidth * 0.7, buildingTop - 20);
                                cityPath.lineTo(x + buildingWidth * 0.7, buildingTop);
                                cityPath.lineTo(x + buildingWidth, buildingTop);
                            } else {
                                // Flat roof
                                cityPath.lineTo(x + buildingWidth, buildingTop);
                            }

                            // Building right side
                            cityPath.lineTo(x + buildingWidth, baseY);

                            x += buildingWidth + Math.random() * 5;
                        }

                        cityPath.lineTo(width, baseY);
                        cityPath.lineTo(width, height);
                        cityPath.closePath();

                        // Generate windows for each building
                        for (const b of buildings) {
                            b.windows = [];
                            const windowWidth = 4;
                            const windowHeight = 6;
                            const spacingX = 8;
                            const spacingY = 12;
                            const marginX = 6;
                            const marginY = 10;

                            const cols = Math.floor((b.width - marginX * 2) / spacingX);
                            const rows = Math.floor((b.height - marginY * 2) / spacingY);

                            for (let row = 0; row < rows; row++) {
                                for (let col = 0; col < cols; col++) {
                                    // ~60% chance window is lit
                                    if (Math.random() < 0.6) {
                                        b.windows.push({
                                            x: b.x + marginX + col * spacingX,
                                            y: b.y + marginY + row * spacingY,
                                            w: windowWidth,
                                            h: windowHeight,
                                            // Warm yellow/orange tint
                                            color: Math.random() < 0.8
                                                ? `rgba(255, ${200 + Math.random() * 55}, ${100 + Math.random() * 50}, ${0.7 + Math.random() * 0.3})`
                                                : `rgba(200, 220, 255, ${0.5 + Math.random() * 0.3})` // Some cool blue lights
                                        });
                                    }
                                }
                            }
                        }
                    }
                    generateCity();

                    // Regenerate city on resize
                    const originalResize = window.onresize;
                    window.addEventListener('resize', function() {
                        setTimeout(generateCity, 10);
                    });

                    function randRange(arr) {
                        return arr[0] + Math.random() * (arr[1] - arr[0]);
                    }

                    function createFirework() {
                        const launchType = Math.random();
                        let x, y, vx, vy, targetY;

                        if (launchType < CONFIG.leftLaunchChance) {
                            // Launch from left side diagonally
                            x = -10;
                            y = height * randRange(CONFIG.sideStartY);
                            targetY = height * randRange(CONFIG.sideTargetY);
                            const targetX = width * randRange(CONFIG.sideTargetX);
                            const angle = Math.atan2(targetY - y, targetX - x);
                            const speed = randRange(CONFIG.sideSpeed);
                            vx = Math.cos(angle) * speed;
                            vy = Math.sin(angle) * speed;
                        } else if (launchType < CONFIG.leftLaunchChance + CONFIG.rightLaunchChance) {
                            // Launch from right side diagonally
                            x = width + 10;
                            y = height * randRange(CONFIG.sideStartY);
                            targetY = height * randRange(CONFIG.sideTargetY);
                            const targetX = width * randRange(CONFIG.sideTargetX);
                            const angle = Math.atan2(targetY - y, targetX - x);
                            const speed = randRange(CONFIG.sideSpeed);
                            vx = Math.cos(angle) * speed;
                            vy = Math.sin(angle) * speed;
                        } else {
                            // Launch from bottom (classic)
                            x = width * randRange(CONFIG.bottomStartX);
                            y = height + 10;
                            targetY = height * randRange(CONFIG.bottomTargetY);
                            vx = (Math.random() - 0.5) * 2;
                            vy = -randRange(CONFIG.bottomSpeed);
                        }

                        const colorSet = colors[Math.floor(Math.random() * colors.length)];
                        return {
                            x, y, vx, vy, targetY,
                            colorSet,
                            trail: [],
                            sparkTimer: 0
                        };
                    }

                    function explode(firework) {
                        const particleCount = Math.floor(randRange(CONFIG.particleCount));
                        const explosionType = Math.random();
                        const baseSpeed = randRange(CONFIG.particleSpeed);

                        for (let i = 0; i < particleCount; i++) {
                            const angle = (Math.PI * 2 * i) / particleCount + (Math.random() - 0.5) * 0.3;
                            let speed = baseSpeed * (0.5 + Math.random() * 0.8);

                            // Add some variation for different explosion shapes
                            if (explosionType > 0.7) {
                                // Ring explosion
                                speed = baseSpeed * (0.9 + Math.random() * 0.2);
                            } else if (explosionType > 0.4) {
                                // Willow effect - slower with more hang time
                                speed = baseSpeed * (0.3 + Math.random() * 0.5);
                            }

                            const colorIndex = Math.floor(Math.random() * firework.colorSet.length);
                            particles.push({
                                x: firework.x,
                                y: firework.y,
                                vx: Math.cos(angle) * speed + firework.vx * 0.3,
                                vy: Math.sin(angle) * speed + firework.vy * 0.3,
                                color: firework.colorSet[colorIndex],
                                life: 1,
                                decay: randRange(CONFIG.particleDecay),
                                radius: randRange(CONFIG.particleRadius),
                                twinkle: Math.random() < CONFIG.twinkleChance,
                                twinkleSpeed: 5 + Math.random() * 10
                            });
                        }

                        // Add some glitter sparks
                        for (let i = 0; i < 20; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = 1 + Math.random() * 2;
                            sparks.push({
                                x: firework.x,
                                y: firework.y,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                life: 1,
                                decay: 0.02 + Math.random() * 0.02
                            });
                        }
                    }

                    // Click to create explosion at cursor position
                    canvas.addEventListener('click', function (e) {
                        const rect = canvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        const colorSet = colors[Math.floor(Math.random() * colors.length)];
                        explode({ x, y, vx: 0, vy: 0, colorSet });
                    });

                    let lastLaunch = 0;

                    function update(delta) {
                        const dt = delta / 16.67; // Normalize to ~60fps

                        lastLaunch += delta;
                        if (lastLaunch > CONFIG.launchInterval && fireworks.length < CONFIG.maxFireworks) {
                            fireworks.push(createFirework());
                            lastLaunch = 0;
                        }

                        for (let i = fireworks.length - 1; i >= 0; i--) {
                            const f = fireworks[i];
                            f.trail.push({ x: f.x, y: f.y, age: 0 });
                            if (f.trail.length > 12) f.trail.shift();
                            for (const t of f.trail) t.age += dt;

                            // Apply physics
                            f.vy += CONFIG.gravity * dt;
                            f.vx *= Math.pow(CONFIG.airResistance, dt);
                            f.vy *= Math.pow(CONFIG.airResistance, dt);
                            f.x += f.vx * dt;
                            f.y += f.vy * dt;

                            // Emit sparks while flying
                            f.sparkTimer += delta;
                            if (f.sparkTimer > 30) {
                                sparks.push({
                                    x: f.x + (Math.random() - 0.5) * 4,
                                    y: f.y + (Math.random() - 0.5) * 4,
                                    vx: -f.vx * 0.1 + (Math.random() - 0.5) * 0.5,
                                    vy: -f.vy * 0.1 + Math.random() * 0.5,
                                    life: 0.6,
                                    decay: 0.03
                                });
                                f.sparkTimer = 0;
                            }

                            // Explode when velocity slows or reaches target
                            const speed = Math.sqrt(f.vx * f.vx + f.vy * f.vy);
                            if (f.y <= f.targetY || speed < 2 || f.vy > 1) {
                                explode(f);
                                fireworks.splice(i, 1);
                            }
                        }

                        for (let i = particles.length - 1; i >= 0; i--) {
                            const p = particles[i];
                            p.vy += CONFIG.gravity * 0.6 * dt;
                            p.vx *= Math.pow(0.98, dt);
                            p.vy *= Math.pow(0.98, dt);
                            p.x += p.vx * dt;
                            p.y += p.vy * dt;
                            p.life -= p.decay * dt;
                            if (p.life <= 0) {
                                particles.splice(i, 1);
                            }
                        }

                        for (let i = sparks.length - 1; i >= 0; i--) {
                            const s = sparks[i];
                            s.vy += CONFIG.gravity * 0.3 * dt;
                            s.x += s.vx * dt;
                            s.y += s.vy * dt;
                            s.life -= s.decay * dt;
                            if (s.life <= 0) {
                                sparks.splice(i, 1);
                            }
                        }
                    }

                    function draw() {
                        ctx.clearRect(0, 0, width, height);

                        // Draw dusk sky gradient
                        const skyGradient = ctx.createLinearGradient(0, 0, 0, height);
                        skyGradient.addColorStop(0, '#0a0a14');
                        skyGradient.addColorStop(0.5, '#1a1428');
                        skyGradient.addColorStop(0.8, '#2d1f3d');
                        skyGradient.addColorStop(1, '#3d2952');
                        ctx.fillStyle = skyGradient;
                        ctx.fillRect(0, 0, width, height);

                        // Draw city silhouette
                        if (cityPath) {
                            // Draw city glow (ambient light pollution)
                            const glowGradient = ctx.createLinearGradient(0, height * 0.5, 0, height);
                            glowGradient.addColorStop(0, 'rgba(40, 30, 50, 0)');
                            glowGradient.addColorStop(0.6, 'rgba(60, 40, 70, 0.3)');
                            glowGradient.addColorStop(1, 'rgba(80, 50, 90, 0.5)');
                            ctx.fillStyle = glowGradient;
                            ctx.fillRect(0, height * 0.5, width, height * 0.5);

                            // Building silhouette with slight highlight
                            ctx.fillStyle = '#12121a';
                            ctx.fill(cityPath);

                            // Draw windows
                            for (const b of buildings) {
                                for (const w of b.windows) {
                                    ctx.fillStyle = w.color;
                                    ctx.fillRect(w.x, w.y, w.w, w.h);
                                }
                            }
                        }

                        // Draw firework trails
                        for (const f of fireworks) {
                            for (let i = 0; i < f.trail.length; i++) {
                                const t = f.trail[i];
                                const alpha = (1 - t.age / 12) * 0.6;
                                if (alpha <= 0) continue;
                                const size = 2 * (1 - t.age / 15);
                                ctx.beginPath();
                                ctx.arc(t.x, t.y, Math.max(0.5, size), 0, Math.PI * 2);
                                ctx.fillStyle = `rgba(255,200,100,${alpha})`;
                                ctx.fill();
                            }
                            // Draw firework head with glow
                            ctx.beginPath();
                            ctx.arc(f.x, f.y, 4, 0, Math.PI * 2);
                            ctx.fillStyle = '#ffffee';
                            ctx.fill();
                            ctx.beginPath();
                            ctx.arc(f.x, f.y, 6, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(255,220,150,0.3)';
                            ctx.fill();
                        }

                        // Draw sparks
                        for (const s of sparks) {
                            ctx.beginPath();
                            ctx.arc(s.x, s.y, 1, 0, Math.PI * 2);
                            ctx.fillStyle = `rgba(255,255,200,${s.life})`;
                            ctx.fill();
                        }

                        // Draw particles
                        const time = performance.now();
                        for (const p of particles) {
                            let alpha = p.life;
                            if (p.twinkle) {
                                alpha *= 0.5 + 0.5 * Math.sin(time * p.twinkleSpeed / 1000);
                            }
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.radius * (0.3 + p.life * 0.7), 0, Math.PI * 2);
                            ctx.fillStyle = p.color;
                            ctx.globalAlpha = alpha;
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }
                    }

                    let lastTime = performance.now();
                    function animate(now) {
                        const delta = Math.min(now - lastTime, 50);
                        lastTime = now;
                        update(delta);
                        draw();
                        requestAnimationFrame(animate);
                    }
                    requestAnimationFrame(animate);

                } else if (isDecember) {
                    // Snow for December
                    let snowflakes = [];
                    const SNOWFLAKE_COUNT = 180;

                    function createSnowflake(initial = false) {
                        const depth = Math.random();
                        return {
                            x: Math.random() * width,
                            y: initial ? Math.random() * height : -10,
                            radius: depth * 2.5 + 0.5,
                            speedY: depth * 1.5 + 0.3,
                            speedX: depth * 0.6,
                            phase: Math.random() * Math.PI * 2,
                            opacity: depth * 0.6 + 0.3
                        };
                    }

                    for (let i = 0; i < SNOWFLAKE_COUNT; i++) {
                        snowflakes.push(createSnowflake(true));
                    }

                    let lastTime = performance.now();
                    let windTime = 0;

                    function update(delta) {
                        windTime += delta * 0.0001;
                        const wind = Math.sin(windTime) * 0.5;

                        for (let i = 0; i < snowflakes.length; i++) {
                            const f = snowflakes[i];
                            f.y += f.speedY * delta * 0.06;
                            f.x += (Math.sin(f.phase + f.y * 0.01) + wind) * f.speedX;
                            f.phase += 0.01;

                            if (f.y > height + 10) {
                                snowflakes[i] = createSnowflake(false);
                            }

                            if (f.x > width) f.x = 0;
                            if (f.x < 0) f.x = width;
                        }
                    }

                    function draw() {
                        ctx.clearRect(0, 0, width, height);

                        for (let i = 0; i < snowflakes.length; i++) {
                            const f = snowflakes[i];
                            ctx.beginPath();
                            ctx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
                            ctx.fillStyle = `rgba(255,255,255,${f.opacity})`;
                            ctx.fill();
                        }
                    }

                    function animate(now) {
                        const delta = now - lastTime;
                        lastTime = now;
                        update(delta);
                        draw();
                        requestAnimationFrame(animate);
                    }
                    requestAnimationFrame(animate);

                } else if (isHalloween) {
                    // Jack-o'-lanterns and bats for October
                    const pumpkins = [];
                    const bats = [];
                    const PUMPKIN_COUNT = 8;
                    const BAT_COUNT = 15;

                    function createPumpkin(initial = false) {
                        const size = 30 + Math.random() * 25;
                        return {
                            x: Math.random() * width,
                            y: initial ? Math.random() * height : height + size,
                            size: size,
                            speedY: -(0.3 + Math.random() * 0.4),
                            speedX: (Math.random() - 0.5) * 0.3,
                            bobPhase: Math.random() * Math.PI * 2,
                            bobSpeed: 1 + Math.random() * 0.5,
                            bobAmount: 3 + Math.random() * 5,
                            rotationPhase: Math.random() * Math.PI * 2,
                            rotationSpeed: 0.5 + Math.random() * 0.5,
                            rotationAmount: 0.15 + Math.random() * 0.15,
                            glowPhase: Math.random() * Math.PI * 2,
                            faceType: Math.floor(Math.random() * 3)
                        };
                    }

                    function createBat(initial = false) {
                        const size = 15 + Math.random() * 15;
                        const fromLeft = Math.random() > 0.5;
                        return {
                            x: initial ? Math.random() * width : (fromLeft ? -size * 2 : width + size * 2),
                            y: Math.random() * height * 0.6,
                            size: size,
                            speedX: fromLeft ? (1 + Math.random() * 2) : -(1 + Math.random() * 2),
                            speedY: (Math.random() - 0.5) * 0.5,
                            wingPhase: Math.random() * Math.PI * 2,
                            wingSpeed: 3 + Math.random() * 2,
                            wobblePhase: Math.random() * Math.PI * 2,
                            wobbleAmount: 2 + Math.random() * 3,
                            opacity: 0.6 + Math.random() * 0.4
                        };
                    }

                    for (let i = 0; i < PUMPKIN_COUNT; i++) {
                        pumpkins.push(createPumpkin(true));
                    }
                    for (let i = 0; i < BAT_COUNT; i++) {
                        bats.push(createBat(true));
                    }

                    let lastTime = performance.now();

                    // Click interaction for pumpkins
                    document.addEventListener('click', function (e) {
                        const clickX = e.clientX;
                        const clickY = e.clientY;
                        const pushRadius = 150; // How close you need to click
                        const pushStrength = 2;

                        for (let i = 0; i < pumpkins.length; i++) {
                            const p = pumpkins[i];
                            const dx = p.x - clickX;
                            const dy = p.y - clickY;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < pushRadius && dist > 0) {
                                // Push pumpkin away from click
                                const force = (1 - dist / pushRadius) * pushStrength;
                                p.speedX += (dx / dist) * force;
                                p.speedY += (dy / dist) * force * 0.5;
                                // Add some spin
                                p.rotationSpeed += (Math.random() - 0.5) * 0.5;
                            }
                        }
                    });

                    function update(delta) {
                        // Update pumpkins
                        for (let i = 0; i < pumpkins.length; i++) {
                            const p = pumpkins[i];
                            p.y += p.speedY * delta * 0.05;
                            p.x += p.speedX * delta * 0.05;
                            p.bobPhase += p.bobSpeed * delta * 0.003;
                            p.rotationPhase += p.rotationSpeed * delta * 0.002;
                            p.glowPhase += delta * 0.005;

                            // Damping - gradually return to normal drift
                            p.speedX *= 0.995;
                            p.speedY += 0.001; // Gentle upward pull back
                            p.rotationSpeed *= 0.99; // Slow rotation decay

                            if (p.y < -p.size * 2) {
                                pumpkins[i] = createPumpkin(false);
                            }
                            if (p.x > width + p.size) p.x = -p.size;
                            if (p.x < -p.size) p.x = width + p.size;
                        }

                        // Update bats
                        for (let i = 0; i < bats.length; i++) {
                            const b = bats[i];
                            b.x += b.speedX * delta * 0.06;
                            b.y += b.speedY * delta * 0.06;
                            b.y += Math.sin(b.wobblePhase) * b.wobbleAmount * 0.3;
                            b.wingPhase += b.wingSpeed * delta * 0.01;
                            b.wobblePhase += delta * 0.003;

                            // Reset when off screen
                            if ((b.speedX > 0 && b.x > width + b.size * 2) ||
                                (b.speedX < 0 && b.x < -b.size * 2)) {
                                bats[i] = createBat(false);
                            }
                        }
                    }

                    function drawPumpkin(ctx, p) {
                        ctx.save();
                        ctx.translate(p.x, p.y + Math.sin(p.bobPhase) * p.bobAmount);
                        ctx.rotate(Math.sin(p.rotationPhase) * p.rotationAmount);

                        const s = p.size;
                        const glowIntensity = 0.5 + Math.sin(p.glowPhase) * 0.2;

                        // Glow effect
                        const gradient = ctx.createRadialGradient(0, 0, s * 0.3, 0, 0, s * 1.5);
                        gradient.addColorStop(0, `rgba(255, 150, 0, ${glowIntensity * 0.4})`);
                        gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(-s * 1.5, -s * 1.5, s * 3, s * 3);

                        // Pumpkin body (multiple overlapping ovals)
                        ctx.fillStyle = '#ff6600';
                        for (let i = -2; i <= 2; i++) {
                            ctx.beginPath();
                            ctx.ellipse(i * s * 0.15, 0, s * 0.25, s * 0.4, 0, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // Darker shade overlay
                        ctx.fillStyle = '#cc5500';
                        ctx.beginPath();
                        ctx.ellipse(-s * 0.3, 0, s * 0.12, s * 0.35, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.ellipse(s * 0.3, 0, s * 0.12, s * 0.35, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Stem
                        ctx.fillStyle = '#2d5016';
                        ctx.beginPath();
                        ctx.moveTo(-s * 0.08, -s * 0.35);
                        ctx.quadraticCurveTo(-s * 0.05, -s * 0.55, s * 0.08, -s * 0.5);
                        ctx.lineTo(s * 0.05, -s * 0.35);
                        ctx.fill();

                        // Face (glowing)
                        ctx.fillStyle = `rgba(255, 200, 50, ${glowIntensity})`;

                        // Eyes
                        if (p.faceType === 0) {
                            // Triangle eyes
                            ctx.beginPath();
                            ctx.moveTo(-s * 0.25, -s * 0.1);
                            ctx.lineTo(-s * 0.1, -s * 0.1);
                            ctx.lineTo(-s * 0.175, -s * 0.25);
                            ctx.fill();
                            ctx.beginPath();
                            ctx.moveTo(s * 0.25, -s * 0.1);
                            ctx.lineTo(s * 0.1, -s * 0.1);
                            ctx.lineTo(s * 0.175, -s * 0.25);
                            ctx.fill();
                        } else if (p.faceType === 1) {
                            // Round eyes
                            ctx.beginPath();
                            ctx.arc(-s * 0.17, -s * 0.15, s * 0.1, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.beginPath();
                            ctx.arc(s * 0.17, -s * 0.15, s * 0.1, 0, Math.PI * 2);
                            ctx.fill();
                        } else {
                            // Angry slanted eyes
                            ctx.beginPath();
                            ctx.moveTo(-s * 0.28, -s * 0.2);
                            ctx.lineTo(-s * 0.08, -s * 0.1);
                            ctx.lineTo(-s * 0.12, -s * 0.05);
                            ctx.lineTo(-s * 0.28, -s * 0.1);
                            ctx.fill();
                            ctx.beginPath();
                            ctx.moveTo(s * 0.28, -s * 0.2);
                            ctx.lineTo(s * 0.08, -s * 0.1);
                            ctx.lineTo(s * 0.12, -s * 0.05);
                            ctx.lineTo(s * 0.28, -s * 0.1);
                            ctx.fill();
                        }

                        // Nose
                        ctx.beginPath();
                        ctx.moveTo(0, -s * 0.05);
                        ctx.lineTo(-s * 0.07, s * 0.08);
                        ctx.lineTo(s * 0.07, s * 0.08);
                        ctx.fill();

                        // Mouth (jagged smile)
                        ctx.beginPath();
                        ctx.moveTo(-s * 0.3, s * 0.15);
                        ctx.lineTo(-s * 0.2, s * 0.25);
                        ctx.lineTo(-s * 0.1, s * 0.15);
                        ctx.lineTo(0, s * 0.28);
                        ctx.lineTo(s * 0.1, s * 0.15);
                        ctx.lineTo(s * 0.2, s * 0.25);
                        ctx.lineTo(s * 0.3, s * 0.15);
                        ctx.lineTo(s * 0.2, s * 0.18);
                        ctx.lineTo(s * 0.1, s * 0.1);
                        ctx.lineTo(0, s * 0.2);
                        ctx.lineTo(-s * 0.1, s * 0.1);
                        ctx.lineTo(-s * 0.2, s * 0.18);
                        ctx.fill();

                        ctx.restore();
                    }

                    function drawBat(ctx, b) {
                        ctx.save();
                        ctx.translate(b.x, b.y);
                        ctx.globalAlpha = b.opacity;

                        const s = b.size;
                        const wingFlap = Math.sin(b.wingPhase) * 0.4;

                        ctx.fillStyle = '#1a1a2e';

                        // Body
                        ctx.beginPath();
                        ctx.ellipse(0, 0, s * 0.2, s * 0.35, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Head
                        ctx.beginPath();
                        ctx.arc(0, -s * 0.35, s * 0.18, 0, Math.PI * 2);
                        ctx.fill();

                        // Ears
                        ctx.beginPath();
                        ctx.moveTo(-s * 0.12, -s * 0.45);
                        ctx.lineTo(-s * 0.18, -s * 0.65);
                        ctx.lineTo(-s * 0.05, -s * 0.5);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(s * 0.12, -s * 0.45);
                        ctx.lineTo(s * 0.18, -s * 0.65);
                        ctx.lineTo(s * 0.05, -s * 0.5);
                        ctx.fill();

                        // Eyes
                        ctx.fillStyle = '#ff4444';
                        ctx.beginPath();
                        ctx.arc(-s * 0.07, -s * 0.38, s * 0.04, 0, Math.PI * 2);
                        ctx.arc(s * 0.07, -s * 0.38, s * 0.04, 0, Math.PI * 2);
                        ctx.fill();

                        // Wings
                        ctx.fillStyle = '#1a1a2e';

                        // Left wing
                        ctx.save();
                        ctx.rotate(wingFlap);
                        ctx.beginPath();
                        ctx.moveTo(-s * 0.15, -s * 0.1);
                        ctx.quadraticCurveTo(-s * 0.6, -s * 0.5, -s * 1.0, -s * 0.2);
                        ctx.lineTo(-s * 0.85, s * 0.05);
                        ctx.lineTo(-s * 0.65, -s * 0.05);
                        ctx.lineTo(-s * 0.5, s * 0.1);
                        ctx.lineTo(-s * 0.35, 0);
                        ctx.lineTo(-s * 0.15, s * 0.15);
                        ctx.fill();
                        ctx.restore();

                        // Right wing
                        ctx.save();
                        ctx.rotate(-wingFlap);
                        ctx.beginPath();
                        ctx.moveTo(s * 0.15, -s * 0.1);
                        ctx.quadraticCurveTo(s * 0.6, -s * 0.5, s * 1.0, -s * 0.2);
                        ctx.lineTo(s * 0.85, s * 0.05);
                        ctx.lineTo(s * 0.65, -s * 0.05);
                        ctx.lineTo(s * 0.5, s * 0.1);
                        ctx.lineTo(s * 0.35, 0);
                        ctx.lineTo(s * 0.15, s * 0.15);
                        ctx.fill();
                        ctx.restore();

                        ctx.restore();
                    }

                    function draw() {
                        ctx.clearRect(0, 0, width, height);

                        // Draw bats first (behind pumpkins)
                        for (let i = 0; i < bats.length; i++) {
                            drawBat(ctx, bats[i]);
                        }

                        // Draw pumpkins
                        for (let i = 0; i < pumpkins.length; i++) {
                            drawPumpkin(ctx, pumpkins[i]);
                        }
                    }

                    function animate(now) {
                        const delta = now - lastTime;
                        lastTime = now;
                        update(delta);
                        draw();
                        requestAnimationFrame(animate);
                    }
                    requestAnimationFrame(animate);

                } else if (isAutumn) {
                    // Falling leaves for September and November
                    let leaves = [];
                    const LEAF_COUNT = 50;

                    // Autumn leaf colors
                    const leafColors = [
                        '#c0392b', // deep red
                        '#e74c3c', // red
                        '#d35400', // burnt orange
                        '#e67e22', // orange
                        '#f39c12', // golden yellow
                        '#f1c40f', // yellow
                        '#935116', // brown
                        '#a04000', // rust
                        '#cb4335', // crimson
                        '#dc7633'  // light orange
                    ];

                    function createLeaf(initial = false) {
                        const depth = 0.3 + Math.random() * 0.7;
                        const size = depth * 12 + 6;
                        return {
                            x: Math.random() * width,
                            y: initial ? Math.random() * height : -size * 2,
                            size: size,
                            speedY: depth * 1.2 + 0.4,
                            speedX: (Math.random() - 0.5) * 0.8,
                            rotation: Math.random() * Math.PI * 2,
                            rotationSpeed: (Math.random() - 0.5) * 0.03,
                            swayPhase: Math.random() * Math.PI * 2,
                            swaySpeed: 0.5 + Math.random() * 1,
                            swayAmount: 0.5 + Math.random() * 1.5,
                            color: leafColors[Math.floor(Math.random() * leafColors.length)],
                            opacity: depth * 0.5 + 0.4,
                            leafType: Math.floor(Math.random() * 3) // 0: maple, 1: oak, 2: simple
                        };
                    }

                    for (let i = 0; i < LEAF_COUNT; i++) {
                        leaves.push(createLeaf(true));
                    }

                    let lastTime = performance.now();
                    let windTime = 0;

                    function update(delta) {
                        windTime += delta * 0.00008;
                        const wind = Math.sin(windTime) * 1.5 + Math.sin(windTime * 2.3) * 0.5;

                        for (let i = 0; i < leaves.length; i++) {
                            const leaf = leaves[i];

                            // Vertical fall
                            leaf.y += leaf.speedY * delta * 0.04;

                            // Horizontal sway + wind
                            const sway = Math.sin(leaf.swayPhase) * leaf.swayAmount;
                            leaf.x += (sway + wind * 0.3 + leaf.speedX) * delta * 0.02;
                            leaf.swayPhase += leaf.swaySpeed * delta * 0.003;

                            // Rotation
                            leaf.rotation += leaf.rotationSpeed * delta * 0.1;

                            // Reset when off screen
                            if (leaf.y > height + leaf.size * 2) {
                                leaves[i] = createLeaf(false);
                                leaves[i].x = Math.random() * width;
                            }

                            // Wrap horizontally
                            if (leaf.x > width + leaf.size) leaf.x = -leaf.size;
                            if (leaf.x < -leaf.size) leaf.x = width + leaf.size;
                        }
                    }

                    function drawLeaf(ctx, leaf) {
                        ctx.save();
                        ctx.translate(leaf.x, leaf.y);
                        ctx.rotate(leaf.rotation);
                        ctx.globalAlpha = leaf.opacity;

                        const s = leaf.size;

                        if (leaf.leafType === 0) {
                            // Maple-style leaf
                            ctx.beginPath();
                            ctx.moveTo(0, -s * 0.8);
                            ctx.quadraticCurveTo(s * 0.3, -s * 0.6, s * 0.7, -s * 0.5);
                            ctx.quadraticCurveTo(s * 0.5, -s * 0.2, s * 0.8, 0);
                            ctx.quadraticCurveTo(s * 0.4, 0.1, s * 0.5, s * 0.4);
                            ctx.quadraticCurveTo(s * 0.2, s * 0.3, 0, s * 0.6);
                            ctx.quadraticCurveTo(-s * 0.2, s * 0.3, -s * 0.5, s * 0.4);
                            ctx.quadraticCurveTo(-s * 0.4, 0.1, -s * 0.8, 0);
                            ctx.quadraticCurveTo(-s * 0.5, -s * 0.2, -s * 0.7, -s * 0.5);
                            ctx.quadraticCurveTo(-s * 0.3, -s * 0.6, 0, -s * 0.8);
                            ctx.fillStyle = leaf.color;
                            ctx.fill();
                        } else if (leaf.leafType === 1) {
                            // Oak-style leaf (rounded lobes)
                            ctx.beginPath();
                            ctx.moveTo(0, -s * 0.7);
                            ctx.bezierCurveTo(s * 0.4, -s * 0.5, s * 0.5, -s * 0.2, s * 0.4, 0);
                            ctx.bezierCurveTo(s * 0.6, s * 0.2, s * 0.4, s * 0.5, s * 0.2, s * 0.6);
                            ctx.quadraticCurveTo(0, s * 0.7, -s * 0.2, s * 0.6);
                            ctx.bezierCurveTo(-s * 0.4, s * 0.5, -s * 0.6, s * 0.2, -s * 0.4, 0);
                            ctx.bezierCurveTo(-s * 0.5, -s * 0.2, -s * 0.4, -s * 0.5, 0, -s * 0.7);
                            ctx.fillStyle = leaf.color;
                            ctx.fill();
                        } else {
                            // Simple oval leaf
                            ctx.beginPath();
                            ctx.ellipse(0, 0, s * 0.35, s * 0.6, 0, 0, Math.PI * 2);
                            ctx.fillStyle = leaf.color;
                            ctx.fill();
                            // Stem
                            ctx.beginPath();
                            ctx.moveTo(0, s * 0.6);
                            ctx.lineTo(0, s * 0.85);
                            ctx.strokeStyle = '#5d4037';
                            ctx.lineWidth = s * 0.06;
                            ctx.stroke();
                        }

                        ctx.restore();
                    }

                    function draw() {
                        ctx.clearRect(0, 0, width, height);

                        for (let i = 0; i < leaves.length; i++) {
                            drawLeaf(ctx, leaves[i]);
                        }
                    }

                    function animate(now) {
                        const delta = now - lastTime;
                        lastTime = now;
                        update(delta);
                        draw();
                        requestAnimationFrame(animate);
                    }
                    requestAnimationFrame(animate);
                }
            });
        })();
    </script>
</head>

<body>
    <header class="banner">
        <img id="photo" src="/photo.jpg">
        <h1>Steven Hicks</h1>
        <div class="socials">
            <ul>
                <li>
                    <a target="_blank" href="https://github.com/stevenah/">GitHub</a>
                </li>
                <li>
                    |
                </li>
                <li>
                    <a target="_blank" href="https://scholar.google.com/citations?user=2fVVFSwAAAAJ&hl">Scholar</a>
                </li>
                <li>
                    |
                </li>
                <li>
                    <a target="_blank" href="/resume.pdf">Resume</a>
                </li>
            </ul>
        </div>
    </header>
    <article class="resume">
        <!-- sections/bio.html -->
        <!-- sections/work.html -->
        <!-- sections/education.html -->
        <!-- sections/projects.html -->
        <!-- sections/activities.html -->
    </article>
</body>

</html>